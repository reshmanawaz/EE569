{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red15\green112\blue16;\red148\green0\blue242;
\red8\green0\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c50196\c7451;\cssrgb\c65490\c3529\c96078;
\cssrgb\c5490\c0\c100000;}
\margl1440\margr1440\vieww11520\viewh11580\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs20 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2  \cf3 \strokec3 % Reading the blanket images (1-9)\cf0 \strokec2 \
blanket_input_image1 = readgrey(\cf4 \strokec4 'train/blanket_1.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image2 = readgrey(\cf4 \strokec4 'train/blanket_2.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image3 = readgrey(\cf4 \strokec4 'train/blanket_3.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image4 = readgrey(\cf4 \strokec4 'train/blanket_4.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image5 = readgrey(\cf4 \strokec4 'train/blanket_5.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image6 = readgrey(\cf4 \strokec4 'train/blanket_6.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image7 = readgrey(\cf4 \strokec4 'train/blanket_7.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image8 = readgrey(\cf4 \strokec4 'train/blanket_8.raw'\cf0 \strokec2 , 128, 128);\
blanket_input_image9 = readgrey(\cf4 \strokec4 'train/blanket_9.raw'\cf0 \strokec2 , 128, 128);\
\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 % Reading the brick images (1-9)\cf0 \strokec2 \
brick_input_image1 = readgrey(\cf4 \strokec4 'train/brick_1.raw'\cf0 \strokec2 , 128, 128);\
brick_input_image2 = readgrey(\cf4 \strokec4 'train/brick_2.raw'\cf0 \strokec2 , 128, 128);\
brick_input_image3 = readgrey(\cf4 \strokec4 'train/brick_3.raw'\cf0 \strokec2 , 128, 128); \
brick_input_image4 = readgrey(\cf4 \strokec4 'train/brick_4.raw'\cf0 \strokec2 , 128, 128);\
brick_input_image5 = readgrey(\cf4 \strokec4 'train/brick_5.raw'\cf0 \strokec2 , 128, 128);\
brick_input_image6 = readgrey(\cf4 \strokec4 'train/brick_6.raw'\cf0 \strokec2 , 128, 128);\
brick_input_image7 = readgrey(\cf4 \strokec4 'train/brick_7.raw'\cf0 \strokec2 , 128, 128);\
brick_input_image8 = readgrey(\cf4 \strokec4 'train/brick_8.raw'\cf0 \strokec2 , 128, 128);\
brick_input_image9 = readgrey(\cf4 \strokec4 'train/brick_9.raw'\cf0 \strokec2 , 128, 128);\
\
\cf3 \strokec3 % Reading the grass images (1-9)\cf0 \strokec2 \
grass_input_image1 = readgrey(\cf4 \strokec4 'train/grass_1.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image2 = readgrey(\cf4 \strokec4 'train/grass_2.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image3 = readgrey(\cf4 \strokec4 'train/grass_3.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image4 = readgrey(\cf4 \strokec4 'train/grass_4.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image5 = readgrey(\cf4 \strokec4 'train/grass_5.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image6 = readgrey(\cf4 \strokec4 'train/grass_6.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image7 = readgrey(\cf4 \strokec4 'train/grass_7.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image8 = readgrey(\cf4 \strokec4 'train/grass_8.raw'\cf0 \strokec2 , 128, 128);\
grass_input_image9 = readgrey(\cf4 \strokec4 'train/grass_9.raw'\cf0 \strokec2 , 128, 128);\
\
\cf3 \strokec3 % Reading the stone images (1-9)\cf0 \strokec2 \
stone_input_image1 = readgrey(\cf4 \strokec4 'train/stones_1.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image2 = readgrey(\cf4 \strokec4 'train/stones_2.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image3 = readgrey(\cf4 \strokec4 'train/stones_3.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image4 = readgrey(\cf4 \strokec4 'train/stones_4.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image5 = readgrey(\cf4 \strokec4 'train/stones_5.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image6 = readgrey(\cf4 \strokec4 'train/stones_6.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image7 = readgrey(\cf4 \strokec4 'train/stones_7.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image8 = readgrey(\cf4 \strokec4 'train/stones_8.raw'\cf0 \strokec2 , 128, 128);\
stone_input_image9 = readgrey(\cf4 \strokec4 'train/stones_9.raw'\cf0 \strokec2 , 128, 128);\
\
\cf3 \strokec3 %5x5 filter laws: \cf0 \strokec2 \
level = [1 4 6 4 1];\
edge = [-1 -2 0 2 1];\
spot = [-1 0 2 0 -1];\
wave = [-1 2 0 -2 1];\
ripple = [1 -4 6 -4 1];\
\
\cf3 \strokec3 %extend the boundry of blanket images and update the feature vectors \cf0 \strokec2 \
\
train_blanket_input_image1 = boundry_extension(blanket_input_image1, 128);\
update_blanket_input_image1 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image1, 128);\
\
train_blanket_input_image2 = boundry_extension(blanket_input_image2, 128);\
update_blanket_input_image2 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image2, 128);\
\
train_blanket_input_image3 = boundry_extension(blanket_input_image3, 128);\
update_blanket_input_image3 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image3, 128);\
\
train_blanket_input_image4 = boundry_extension(blanket_input_image4, 128);\
update_blanket_input_image4 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image4, 128);\
\
train_blanket_input_image5 = boundry_extension(blanket_input_image5, 128);\
update_blanket_input_image5 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image5, 128);\
\
train_blanket_input_image6 = boundry_extension(blanket_input_image6, 128);\
update_blanket_input_image6 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image6, 128);\
\
train_blanket_input_image7 = boundry_extension(blanket_input_image7, 128);\
update_blanket_input_image7 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image7, 128);\
\
train_blanket_input_image8 = boundry_extension(blanket_input_image8, 128);\
update_blanket_input_image8 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image8, 128);\
\
train_blanket_input_image9 = boundry_extension(blanket_input_image9, 128);\
update_blanket_input_image9 = update_vector(level, edge, spot, wave, ripple, train_blanket_input_image9, 128);\
\
\
\cf3 \strokec3 %extend the boundry of brick images and update the feature vectors \cf0 \strokec2 \
\
train_brick_input_image1 = boundry_extension(brick_input_image1, 128);\
update_brick_input_image1 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image1, 128);\
\
train_brick_input_image2 = boundry_extension(brick_input_image2, 128);\
update_brick_input_image2 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image2, 128);\
\
train_brick_input_image3 = boundry_extension(brick_input_image3, 128);\
update_brick_input_image3 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image3, 128);\
\
train_brick_input_image4 = boundry_extension(brick_input_image4, 128);\
update_brick_input_image4 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image4, 128);\
\
train_brick_input_image5 = boundry_extension(brick_input_image5, 128);\
update_brick_input_image5 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image5, 128);\
\
train_brick_input_image6 = boundry_extension(brick_input_image6, 128);\
update_brick_input_image6 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image6, 128);\
\
train_brick_input_image7 = boundry_extension(brick_input_image7, 128);\
update_brick_input_image7 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image7, 128);\
\
train_brick_input_image8 = boundry_extension(brick_input_image8, 128);\
update_brick_input_image8 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image8, 128);\
\
train_brick_input_image9 = boundry_extension(brick_input_image9, 128);\
update_brick_input_image9 = update_vector(level, edge, spot, wave, ripple, train_brick_input_image9, 128);\
\
\
\cf3 \strokec3 %extend the boundry of grass images and update the feature vectors \cf0 \strokec2 \
\
train_grass_input_image1 = boundry_extension(grass_input_image1, 128);\
update_grass_input_image1 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image1, 128);\
\
train_grass_input_image2 = boundry_extension(grass_input_image2, 128);\
update_grass_input_image2 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image2, 128);\
\
train_grass_input_image3 = boundry_extension(grass_input_image3, 128);\
update_grass_input_image3 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image3, 128);\
\
train_grass_input_image4 = boundry_extension(grass_input_image4, 128);\
update_grass_input_image4 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image4, 128);\
\
train_grass_input_image5 = boundry_extension(grass_input_image5, 128);\
update_grass_input_image5 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image5, 128);\
\
train_grass_input_image6 = boundry_extension(grass_input_image6, 128);\
update_grass_input_image6 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image6, 128);\
\
train_grass_input_image7 = boundry_extension(grass_input_image7, 128);\
update_grass_input_image7 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image7, 128);\
\
train_grass_input_image8 = boundry_extension(grass_input_image8, 128);\
update_grass_input_image8 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image8, 128);\
\
train_grass_input_image9 = boundry_extension(grass_input_image9, 128);\
update_grass_input_image9 = update_vector(level, edge, spot, wave, ripple, train_grass_input_image9, 128);\
\
\cf3 \strokec3 %extend the boundry of stone images and update the feature vectors \cf0 \strokec2 \
\
train_stone_input_image1 = boundry_extension(stone_input_image1, 128);\
update_stone_input_image1 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image1, 128);\
\
train_stone_input_image2 = boundry_extension(stone_input_image2, 128);\
update_stone_input_image2 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image2, 128);\
\
train_stone_input_image3 = boundry_extension(stone_input_image3, 128);\
update_stone_input_image3 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image3, 128);\
\
train_stone_input_image4 = boundry_extension(stone_input_image4, 128);\
update_stone_input_image4 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image4, 128);\
\
train_stone_input_image5 = boundry_extension(stone_input_image5, 128);\
update_stone_input_image5 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image5, 128);\
\
train_stone_input_image6 = boundry_extension(stone_input_image6, 128);\
update_stone_input_image6 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image6, 128);\
\
train_stone_input_image7 = boundry_extension(stone_input_image7, 128);\
update_stone_input_image7 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image7, 128);\
\
train_stone_input_image8 = boundry_extension(stone_input_image8, 128);\
update_stone_input_image8 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image8, 128);\
\
train_stone_input_image9 = boundry_extension(stone_input_image9, 128);\
update_stone_input_image9 = update_vector(level, edge, spot, wave, ripple, train_stone_input_image9, 128);\
\
update_vector_total = [\
    update_blanket_input_image1; update_blanket_input_image2; update_blanket_input_image3;\
    update_blanket_input_image4; update_blanket_input_image5; update_blanket_input_image6;\
    update_blanket_input_image7; update_blanket_input_image8; update_blanket_input_image9;\
    update_brick_input_image1; update_brick_input_image2; update_brick_input_image3;\
    update_brick_input_image4; update_brick_input_image5; update_brick_input_image6;\
    update_brick_input_image7; update_brick_input_image8; update_brick_input_image9;\
    update_grass_input_image1; update_grass_input_image2; update_grass_input_image3;\
    update_grass_input_image4; update_grass_input_image5; update_grass_input_image6;\
    update_grass_input_image7; update_grass_input_image8; update_grass_input_image9;\
    update_stone_input_image1; update_stone_input_image2; update_stone_input_image3;\
    update_stone_input_image4; update_stone_input_image5; update_stone_input_image6;\
    update_stone_input_image7; update_stone_input_image8; update_stone_input_image9\
];\
\
\cf3 \strokec3 %Feature dimension reduction via Principal Component Analysis (PCA)\cf0 \strokec2 \
\
\cf3 \strokec3 % Step 1: 'data_matrix' with size [36, 25]\cf0 \strokec2 \
data_matrix = zscore(update_vector_total);  \cf3 \strokec3 % Standardize the data\cf0 \strokec2 \
\
\cf3 \strokec3 % Step 2: Perform PCA\cf0 \strokec2 \
[coeff, ~, ~, ~, ~] = pca(data_matrix);\
\
\cf3 \strokec3 % Step 3: Select the top 3 principal components\cf0 \strokec2 \
reduced_loadings = coeff(:, 1:3);\
\
\cf3 \strokec3 % Step 4: Transform the data to 3-dimensional space\cf0 \strokec2 \
reduced_data = data_matrix * reduced_loadings;\
\
\cf3 \strokec3 % Step 5: Plot the reduced 3-D feature vectors\cf0 \strokec2 \
figure;\
scatter3(reduced_data(:,1), reduced_data(:,2), reduced_data(:,3), \cf4 \strokec4 'filled'\cf0 \strokec2 );\
xlabel(\cf4 \strokec4 'Principal Component 1'\cf0 \strokec2 );\
ylabel(\cf4 \strokec4 'Principal Component 2'\cf0 \strokec2 );\
zlabel(\cf4 \strokec4 'Principal Component 3'\cf0 \strokec2 );\
title(\cf4 \strokec4 '3-D Feature Vectors after PCA'\cf0 \strokec2 );\
grid \cf4 \strokec4 on\cf0 \strokec2 ;\
\
\cf3 \strokec3 % Function to Extend the Boundry: \cf0 \strokec2 \
\pard\pardeftab720\partightenfactor0
\cf5 \strokec5 function \cf0 \strokec2 J = boundry_extension(image, size)\
    image_double = double(image);\
    \
    \cf3 \strokec3 % Calculate the sum of all elements in the input image\cf0 \strokec2 \
    total_sum = sum(sum(image_double));\
    \
    \cf3 \strokec3 % Calculate the mean value\cf0 \strokec2 \
    mean_value = total_sum / (size * size);\
    \
    \cf3 \strokec3 % Subtract the mean value from each element of the input image\cf0 \strokec2 \
    subtracted_image = image_double - mean_value;\
    \
    \cf3 \strokec3 % Convert the subtracted image to double\cf0 \strokec2 \
    I = double(subtracted_image);\
\
    \cf3 \strokec3 % Initialize a matrix J with dimensions (size+4) x (size+4) filled with zeros\cf0 \strokec2 \
    J = zeros(size+4, size+4);\
    \
    \cf3 \strokec3 % Set the central region of J (excluding extended boundaries) to be\cf0 \strokec2 \
    \cf3 \strokec3 % equal to the processed image I\cf0 \strokec2 \
    J(3:size+2, 3:size+2) = I;\
    \
    \cf3 \strokec3 % Extend the second row of J using the second row of the processed image I\cf0 \strokec2 \
    J(2, 3:size+2) = I(2, :);\
    \
    \cf3 \strokec3 % Extend the first row of J using the third row of the processed image I\cf0 \strokec2 \
    J(1, 3:size+2) = I(3, :);\
    \
    \cf3 \strokec3 % Extend the (size+3)th row of J using the (size-1)th row of \cf0 \strokec2 \
    \cf3 \strokec3 % the processed image I\cf0 \strokec2 \
    J(size+3, 3:size+2) = I(size-1, :);\
    \
    \cf3 \strokec3 % Extend the (size+4)th row of J using the (size-2)th row of \cf0 \strokec2 \
    \cf3 \strokec3 % the processed image I\cf0 \strokec2 \
    J(size+4, 3:size+2) = I(size-2, :);\
    \
    \cf3 \strokec3 % Extend the second column of J using the fourth column of J\cf0 \strokec2 \
    J(:, 2) = J(:, 4);\
    \
    \cf3 \strokec3 % Extend the first column of J using the fifth column of J \cf0 \strokec2 \
    \cf3 \strokec3 % 5x5 filter bank response computation \cf0 \strokec2 \
    J(:, 1) = J(:, 5);\
    \
    \cf3 \strokec3 % Extend the (size+3)th column of J using the (size+1)th column of J\cf0 \strokec2 \
    J(:, size+3) = J(:, size+1);\
    \
    \cf3 \strokec3 % Extend the (size+4)th column of J using the (size)th column of J\cf0 \strokec2 \
    J(:, size+4) = J(:, size);\
          \
\cf5 \strokec5 end\cf0 \strokec2 \
\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 %Function to calculate a set of energy features based on input matrices\cf0 \strokec2 \
\cf3 \strokec3 % Calculate the Average Energy for Each Filter to Form a 25D Feature Vector\cf0 \strokec2 \
\cf3 \strokec3 % by mult the transpose \cf0 \strokec2 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \strokec5 function \cf0 \strokec2 J = update_vector(level,edge,spot,wave,ripple, extended_image, size)\
    l1 = avg_eng(level'*level, extended_image, 128);\
    \
    l2 = avg_eng(level'*edge, extended_image, 128);\
    l3 = avg_eng(level'*spot, extended_image, 128);\
    l4 = avg_eng(level'*wave, extended_image, 128);\
    l5 = avg_eng(level'*ripple, extended_image, 128);\
\
    e2 = avg_eng(edge'*edge, extended_image, 128);\
\
    e1 = avg_eng(edge'*level, extended_image, 128);\
    e3 = avg_eng(edge'*spot, extended_image, 128);\
    e4 = avg_eng(edge'*wave, extended_image, 128);\
    e5 = avg_eng(edge'*ripple, extended_image, 128);\
\
    s3 = avg_eng(spot'*spot, extended_image, 128);\
\
    s1 = avg_eng(spot'*level, extended_image, 128);\
    s2 = avg_eng(spot'*edge, extended_image, 128);\
    s4 = avg_eng(spot'*wave, extended_image, 128);\
    s5 = avg_eng(spot'*ripple, extended_image, 128);\
\
    w4 = avg_eng(wave'*wave, extended_image, 128);\
\
    w1 = avg_eng(wave'*level, extended_image, 128);\
    w2 = avg_eng(wave'*edge, extended_image, 128);\
    w3 = avg_eng(wave'*spot, extended_image, 128);\
    w5 = avg_eng(wave'*ripple, extended_image, 128);\
\
    r5 = avg_eng(ripple'*ripple, extended_image, 128);\
\
    r1 = avg_eng(ripple'*level, extended_image, 128);\
    r2 = avg_eng(ripple'*edge, extended_image, 128);\
    r3 = avg_eng(ripple'*spot, extended_image, 128);\
    r4 = avg_eng(ripple'*wave, extended_image, 128);\
\
    \cf3 \strokec3 %call the update feature vector function \cf0 \strokec2 \
    m1 = ((l2 + e1) / 2);\
    m2 = ((e3 + s2) / 2);\
    m3 = ((l3 + s1) / 2);\
    m4 = ((e4 + w2) / 2);\
    m5 = ((l4 + w1) / 2);\
    m6 = ((e5 + r2) / 2);\
    m7 = ((l5 + r1) / 2);\
    m8 = ((s4 + w3) / 2);\
    m9 = ((w5 + r4) / 2);\
    m10 = ((s5 + r3) / 2);\
\
    eng_vec = [m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, r5, s3, e2, l1, w4];\
    J = eng_vec;\
\cf5 \strokec5 end\cf0 \strokec2 \
\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 % Each Pixel Value Needs to be Squared, Then Summed, \cf0 \strokec2 \
\cf3 \strokec3 % Then Divided by the Number of Pixels = Average Energy\cf0 \strokec2 \
\
\
\cf3 \strokec3 % find the average energy of a given filter response over the extended boundry \cf0 \strokec2 \
\pard\pardeftab720\partightenfactor0
\cf5 \strokec5 function \cf0 \strokec2 energy = avg_eng(filter, extended_image, size)\
\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 % Initialize total energy\cf0 \strokec2 \
energy = 0;\
\
\cf3 \strokec3 % Iterate over each pixel in the extended boundary image\cf0 \strokec2 \
\pard\pardeftab720\partightenfactor0
\cf5 \strokec5 for \cf0 \strokec2 row = 3:size+2\
    \cf5 \strokec5 for \cf0 \strokec2 col = 3:size+2\
        \cf3 \strokec3 % Initialize local average\cf0 \strokec2 \
        local_avg = 0;\
        \
        \cf3 \strokec3 % Iterate over a 5x5 window around the current pixel\cf0 \strokec2 \
        \cf5 \strokec5 for \cf0 \strokec2 i = -2:2\
            \cf5 \strokec5 for \cf0 \strokec2 j = -2:2\
                \cf3 \strokec3 % Compute the local average by multiplying the pixel\cf0 \strokec2 \
                \cf3 \strokec3 % values with the corresponding filter values and summing\cf0 \strokec2 \
                local_avg = local_avg + (extended_image(row+i, col+j) * filter(i+3, j+3));\
            \cf5 \strokec5 end\cf0 \strokec2 \
        \cf5 \strokec5 end\cf0 \strokec2 \
        \
        \cf3 \strokec3 % Store the local average in the filtered response map\cf0 \strokec2 \
        filtered_response(row-2, col-2) = local_avg;\
        \
        \cf3 \strokec3 % Compute the energy contribution of the current pixel and add it\cf0 \strokec2 \
        \cf3 \strokec3 % to the total energy\cf0 \strokec2 \
        energy = energy + ((1/(size*size)) * abs(filtered_response(row-2, col-2)));\
    \cf5 \strokec5 end\cf0 \strokec2 \
\cf5 \strokec5 end\cf0 \strokec2 \
\cf5 \strokec5 end\cf0 \strokec2 \
}